判断二叉树是否是完全二叉树

1. 有右孩子，无左孩子
2. 第一次遇到左右孩子不双全的时候，之后遍历的节点都是叶子节点
按层遍历，一个节点一个节点看


二叉树递归套路：
可以解决面试中绝大多数的二叉树问题尤其是树型dp问题
本质是利用递归遍历二叉树的便利性


1）假设以X节点为头，假设可以向X左树和X右树要任何信息
2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）
3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
5）递归函数都返回S，每一棵子树都这么要求
6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息


1.判断二叉树是否是搜索二叉树
搜索二叉树，每一颗子树，左边树都比头小，右树都比头节点大
经典二叉树：没有重复值

1. 中序遍历，看一下是否是上升的
2. 递归套路


2.给定一棵二叉树的头节点head，返回这颗二叉树是不是平衡二叉树
平衡二叉树，每一个左树和右树的高度相差不超过1


3.给定一棵二叉树的头节点head，返回这颗二叉树是不是满二叉树
满二叉树：高度是h，节点树是2^h -1 个节点，换句话来说，其实就是求二叉树的高度


4.给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小


给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离


判断二叉树是否是完全二叉树，如何用递归套路来解这个题

给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点

给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先



派对的最大快乐值
员工信息的定义如下:
class Employee {
    public int happy; // 这名员工可以带来的快乐值
    List<Employee> subordinates; // 这名员工有哪些直接下级
}

派对的最大快乐值
公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。
叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。

派对的最大快乐值
这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：
1.如果某个员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。


